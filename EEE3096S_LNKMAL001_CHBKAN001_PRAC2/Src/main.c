/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f051xx.h"
#include "gpio.h"
#include "systick.h"
#include "lcd.h"

#define RCC_CR_HSERDY        (0x1U<<17)
#define RCC_CFGR_SWS_HSE     (0x01<<2)

// Definitions for SPI usage
#define MEM_SIZE 8192 // bytes
#define WREN 0b00000110 // enable writing
#define WRDI 0b00000100 // disable writing
#define RDSR 0b00000101 // read status register
#define WRSR 0b00000001 // write status register
#define READ 0b00000011
#define WRITE 0b00000010


static void RCCConfig(void);         //Switches System Clock to External Clock
static void GPIO_Config(void);       //Initializes GPIO uisng own custom library
void EXTI0_1_IRQHandler(void);
void TIM16_IRQHandler(void);
static void init_spi(void);
static void write_to_address(uint16_t address, uint8_t data);
static uint8_t read_from_address(uint16_t address);
static void TIM16_Enable(void);
static uint8_t patterns[] = {0xAA,0x55,0xCC,0x33,0xF0,0x0F};

static uint16_t address = 0x0000;
static uint32_t arr_value = 999;

int main(void)
{
	RCCConfig();
	GPIO_Config();
	init_spi();



	for (int i=0; i<6; ++i){
		write_to_address(address, patterns[i]);
		address++;

	}
	address =0;
	TIM16_Enable();

	while(1){
		__asm volatile("NOP");

	}

}

/*
 * @Brief: Enables selects External Crystal Oscillator as a system clock for stable Clock
 * @Param: None
 * @Retval: None
 *
 */
static void RCCConfig(void){
	RCC->CR |= (1U<<16);   //HSE ON

	while(!(RCC->CR & RCC_CR_HSERDY));   //Wait until HSE is READY

	RCC->CFGR |= 0x01;      //Switch System Clock to HSE

	while(!(RCC->CFGR & RCC_CFGR_SWS_HSE));   //Wait


}
/*
 * @Brief: Configures PB0-PB7 as output and PA0 as Falling edge trigger Interrupt
 */
static void GPIO_Config(void){
	GPIO_Handle_t ledx;
	GPIO_Handle_t sw0;

	GPIO_ClockConfig(ENABLE, GPIOB);
	GPIO_ClockConfig(ENABLE, GPIOA);

	sw0.GPIOx = GPIOA;
	sw0.GPIOx_Config.AFSEL = AF0;
	sw0.GPIOx_Config.OutPutType = PUSHPULL;   //OutPut Type is by default push pull
	sw0.GPIOx_Config.PinMode = InputMode;
	sw0.GPIOx_Config.PinNumber = GPIO_PIN0;
	sw0.GPIOx_Config.PinSpeed = HIGHSPEED;
	sw0.GPIOx_Config.PullUpPullDown = PullUp;  //Enables PullUp

	GPIO_IRQEnable(&sw0,EXTI0_1_IRQn, FT_INTERRUPT);  //Falling Trigger Interrupt


	ledx.GPIOx = GPIOB;
	ledx.GPIOx_Config.PinNumber = GPIO_PIN0;
	ledx.GPIOx_Config.OutPutType = PUSHPULL;
	ledx.GPIOx_Config.PinSpeed   = MEDIUMSPEED;
	ledx.GPIOx_Config.PinMode = OutputMode;
	ledx.GPIOx_Config.PullUpPullDown = NoPullUpOrPullDown;
	ledx.GPIOx_Config.AFSEL    = AF0;

	GPIO_Init(&ledx);

	ledx.GPIOx_Config.PinNumber = GPIO_PIN1;
	GPIO_Init(&ledx);


	ledx.GPIOx_Config.PinNumber = GPIO_PIN2;
	GPIO_Init(&ledx);


	ledx.GPIOx_Config.PinNumber = GPIO_PIN3;
	GPIO_Init(&ledx);


	ledx.GPIOx_Config.PinNumber = GPIO_PIN4;
	GPIO_Init(&ledx);


	ledx.GPIOx_Config.PinNumber = GPIO_PIN5;
	GPIO_Init(&ledx);


	ledx.GPIOx_Config.PinNumber = GPIO_PIN6;
	GPIO_Init(&ledx);


	ledx.GPIOx_Config.PinNumber = GPIO_PIN7;
	GPIO_Init(&ledx);
}


/*
 * @Brief: Initialiases SPI2 using GPIO user defined driver
 * @Param: None
 * @Retval: None
 * @Note: See gpio.c for gpio initialisation
 *
 */
static void init_spi(void) {


  GPIO_Handle_t spix;
  spix.GPIOx  = GPIOB;
  spix.GPIOx_Config.AFSEL = AF0;
  spix.GPIOx_Config.OutPutType = PUSHPULL;
  spix.GPIOx_Config.PinNumber = GPIO_PIN13;
  spix.GPIOx_Config.PinSpeed = LOWSPEED;
  spix.GPIOx_Config.PullUpPullDown = NoPullUpOrPullDown;
  spix.GPIOx_Config.PinMode = AltFucntionMode;

  GPIO_Init(&spix);

  spix.GPIOx_Config.PinNumber = GPIO_PIN14;
  GPIO_Init(&spix);

  spix.GPIOx_Config.PinNumber = GPIO_PIN15;
  GPIO_Init(&spix);

  spix.GPIOx_Config.PinNumber = GPIO_PIN12;
  spix.GPIOx_Config.PinMode = OutputMode;
  GPIO_Init(&spix);
  GPIO_WritePin(GPIOB, GPIO_PIN12, PIN_SET);   //Set CS PIN HIGH

  // Clock enable to SPI
  RCC->APB1ENR |= RCC_APB1ENR_APB1SPI2EN;
  SPI2->CR1 |= (0x3U<<3); 					            //Set Baud to fpclk / 16
  SPI2->CR1 |= SPI_CR1_MSTR; 							// Set to master mode
  SPI2->CR1 |= SPI_CR1_SSM;                             // Software slave management
  SPI2->CR1 |= SPI_CR1_SSI;                             //Slave internal select enable
  SPI2->CR2 |= 1<<12; 									// Set RX threshold to be 8 bits
  SPI2->CR2 |= SPI_CR2_FRXTH; 	                        // Set to 8-bit mode
  SPI2->CR1 |= SPI_CR1_SPE; 							// Enable the SPI peripheral
}

// Write to EEPROM address using SPI
static void write_to_address(uint16_t address, uint8_t data) {

	uint8_t dummy; // Junk from the DR

	// Set the Write Enable latch
	GPIO_WritePin(GPIOB, GPIO_PIN12, PIN_RESET); //Pull CS Low
	SysTick_Init(1, EXC_DISABLE, MICRO_SECOND);
	*((uint8_t*)(&SPI2->DR)) = WREN;
	while ((SPI2->SR & SPI_SR_RXNE) == 0); // Hang while RX is empty
	dummy = SPI2->DR;
	GPIO_WritePin(GPIOB, GPIO_PIN12, PIN_SET);
	SysTick_Init(5000, EXC_DISABLE, MICRO_SECOND);  //Pull CS High

	// Send write instruction
	GPIO_WritePin(GPIOB, GPIO_PIN12, PIN_RESET);   //Pull CS Low
	SysTick_Init(1, EXC_DISABLE, US_DELAY);
	*((uint8_t*)(&SPI2->DR)) = WRITE;
	while ((SPI2->SR & SPI_SR_RXNE) == 0); 		// Hang while RX is empty
	dummy = SPI2->DR;

	// Send 16-bit address
	*((uint8_t*)(&SPI2->DR)) = (address >> 8); 	// Address MSB
	while ((SPI2->SR & SPI_SR_RXNE) == 0); 		// Hang while RX is empty
	dummy = SPI2->DR;
	*((uint8_t*)(&SPI2->DR)) = (address); 		// Address LSB
	while ((SPI2->SR & SPI_SR_RXNE) == 0); 		// Hang while RX is empty
	dummy = SPI2->DR;

	// Send the data
	*((uint8_t*)(&SPI2->DR)) = data;
	while ((SPI2->SR & SPI_SR_RXNE) == 0); // Hang while RX is empty
	dummy = SPI2->DR;
	GPIO_WritePin(GPIOB, GPIO_PIN12, PIN_SET);
	SysTick_Init(5000, EXC_DISABLE, MICRO_SECOND);  //Pull CS HIGH
}

// Read from EEPROM address using SPI
static uint8_t read_from_address(uint16_t address) {

	uint8_t dummy; // Junk from the DR

	// Send the read instruction
	GPIO_WritePin(GPIOB, GPIO_PIN12, PIN_RESET);   //Pull  CS low
	SysTick_Init(1, EXC_DISABLE, MICRO_SECOND);
	*((uint8_t*)(&SPI2->DR)) = READ;
	while ((SPI2->SR & SPI_SR_RXNE) == 0); 		// Hang while RX is empty
	dummy = SPI2->DR;

	// Send 16-bit address
	*((uint8_t*)(&SPI2->DR)) = (address >> 8); 	// Address MSB
	while ((SPI2->SR & SPI_SR_RXNE) == 0);		// Hang while RX is empty
	dummy = SPI2->DR;
	*((uint8_t*)(&SPI2->DR)) = (address); 		// Address LSB
	while ((SPI2->SR & SPI_SR_RXNE) == 0); 		// Hang while RX is empty
	dummy = SPI2->DR;

	// Clock in the data
	*((uint8_t*)(&SPI2->DR)) = 0x42; 			    // Clock out some junk data
	while ((SPI2->SR & SPI_SR_RXNE) == 0); 		// Hang while RX is empty
	dummy = SPI2->DR;
	GPIO_WritePin(GPIOB, GPIO_PIN12, PIN_SET);
	SysTick_Init(5000, EXC_DISABLE, MICRO_SECOND);;  //Pull CS High

	return dummy;								              // Return read data
}
static void TIM16_Enable(void){
	RCC->APB2ENR |= RCC_APB2ENR_APB2TIM16EN;
	TIM16->PSC = 0x1F3F;   //Setting TIM16 freq to 1kHz
	TIM16->ARR = 0x3E7;    //1s delay
	TIM16->DIER |= TIM_DIER_UIE;  //Update Interrupt flag set
	NVIC_IRQEnable(TIM16_IRQn);   //Enable interrupt for TIM16
	TIM16->CR1 |= TIM_CR1_CEN;    //Enable Counter for TIM16
}
void TIM16_IRQHandler(void){
	__asm volatile("CPSID I");  //disable all global interrupts
	if(TIM16->SR & TIM_SR_UIF){
		TIM16->SR &= 0xFFFE;  //Clear Update Interrupt Flag
		uint8_t data = read_from_address(address);
		if (data!=patterns[address]){
			GPIOB->ODR = 0x0001;  //Wrong pattern
		}

		else{

			GPIOB->ODR = data;  //Correct bit pattern
		}
	}
	address++;
	address%=6;
	__asm volatile("CPSIE I"); //Enable all global interrupts
}
void EXTI0_1_IRQHandler(void){
	__asm volatile("CPSID I");  //Disable all global interrupts
	GPIO_ISRHandler(GPIO_PIN0);  //Clear Corresponding Pending Register Bit
	if(arr_value == 999){
		TIM16->ARR = 499;
		arr_value = 499;
	}
	else{
		TIM16->ARR = 999;
		arr_value = 999;
	}
	__asm volatile("CPSIE I"); //Enable all global interrupts

}
